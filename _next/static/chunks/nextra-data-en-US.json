{"/":{"title":"Nextjs Study!","data":{"":"넥스트js 스터디 with Nextra","_metajson에-대해#_meta.json에 대해":"폴더로 문서의 계층을 구성할 수 있습니다\n해당 파일로 라우터의 순서와 보여지는 이름을 분리시킬 수 있습니다\n_meta.json 파일이 작성되어있지 않아도 작동은하지만\n_meta.json 파일로 문서구조의 순서를 바로잡을 수 있습니다\n_meta.json 파일은 \"실제 폴더-파일명\" : \"문서계층의 폴더-파일명\" 으로 구성됩니다\n파일과 폴더명은 넥스트라처럼 사용하였습니다 (띄어쓰기:-)","이미지첨부에-대해#이미지첨부에 대해":"이미지 이름은 '페이지이름-이미지이름'으로 했습니다.\n마크다운에 이미지 첨부하는 형식은 ![이미지 설명](./이미지 경로)\n에셋폴더에 보관하는것보다 문서랑 가까이두면 좋을것같아서요. 다른 의견있으시면 알려주세용"}},"/page-router/routing/defining-routes":{"title":"Defining Routes","data":{"":""}},"/getting-started/react-essentials":{"title":"React Essentials","data":{"":"","1-서버-컴포넌트#1. 서버 컴포넌트":"클라이언트 컴포넌트(csr) + 서버 컴포넌트(ssr) => 하이브리드","서버-컴포넌트-생각해보기#서버 컴포넌트 생각해보기":"페이지를 컴포넌트 단위로 쪼개다보면 대부분의 컴포넌트는 인터렉션이 없어 서버에서 렌더링이 가능\n인터렉티브 UI의 경우를 제한적으로 클라이언트 컴포넌트로 사용","왜-서버-컴포넌트인가#왜 서버 컴포넌트인가?":"","csr의-경우#CSR의 경우":"느린 초기로딩\n이후 빠른 반응성\n인터렉션 연산을 클라이언트측에 위임","ssr의-경우#SSR의 경우":"빠른 초기 로딩\n라우터 전환시마다 페이지 로딩이 필요","서버-컴포넌트를-사용하면#서버 컴포넌트를 사용하면":"데이터베이스에 더 가까운 서버로 데이터 로드,\n큰 자바스크립트 번들구성을 서버에 유지하여 성능 향상\n서버 컴포넌트를 사용하면 React의 성능과 유연성, UI 템플릿을 위한 컴포넌트 모델을 사용 가능\n클라이언트 컴포넌트와 서버컴포넌트는 점진적으로 클라이언트에게 인계되며\n상호작용을 추가할 수 있도록 서버와 클라이언트 측 런타임을 비동기적으로 로드\n서버컴포넌트는 앱라우터를 포함하여, 스페셜 파일, 코로케이션 컴포넌트를 지칭","2-클라이언트-컴포넌트#2. 클라이언트 컴포넌트":"주로 애플리케이션에 클라이언트 측 인터랙션을 담당\n클라이언트 컴포넌트는 넥스트에서 미리 렌더링되어짐.\nHTML뼈대 생성\n리액트 자바스크립트 채워주기(하이드레이트)\n\n\n페이지 라우터가 항상 작동하는 방식","use-client-디렉티브#\"use client\" 디렉티브":"\"use client\" 지시어를 통해 클라이언트 컴포넌트로 동작\n'use client'\n\nimport { useState } from 'react'\n\nexport default function Counter() {\nconst [count, setCount] = useState(0)\n\nreturn (\n<div>\n<p>You clicked {count} times</p>\n<button onClick={() => setCount(count + 1)}>Click me</button>\n</div>\n)\n}\n\n알아두면 좋은 정보:\n\"use client\"\n임포트 문 위에 위치\n!! 해당 파일에서 임포트한 하위 모듈은 클라이언트 번들로 간주\n이 규칙 때문에 본문에서는 경계라고 표현\n클라이언트 컴포넌트의 최상위 컴포넌트만 디렉티브를 사용하면 댐\n\n\n해당 디렉티브가 없는 모든 컴포넌트는 서버 컴포넌트 -> 서버에서만 렌더링\n(next의 경우) 클라이언트 컴포넌트는 서버에서 미리 렌더링한 후 클라이언트에 하이드레이션\n\n참고\n모듈그래프라는 포현은 넥스트js의 모듈 표현법으로 의존관계에 있는 모듈들이 그래프구조로 연결되기 때문에 모듈그래프라 지칭\n해당 본문에는 모듈그래프라는 표현을 제거해도 이해에 문제가 없을것으로 판단하여 해당표현을 삭제함","3-서버-컴포넌트와-클라이언트-컴포넌트는-언제-사용해야-하나요#3. 서버 컴포넌트와 클라이언트 컴포넌트는 언제 사용해야 하나요?":"기본 : 서버컴포넌트\n\n\n서버 컴포넌트\t클라이언트 컴포넌트\t서버에 민감한 정보(액세스 토큰, API 키 등) 보관\tx\tx\t데이터를 가져옵니다.\to\tx\t백엔드 리소스에 직접 액세스 (직접)\to\tx\t서버에 대한 대규모 종속성 유지/클라이언트 측 자바스크립트 감소\to\tx\t상호작용 및 이벤트 리스너 추가(onClick(), onChange() 등)\tx\to\t상태 및 수명 주기 효과 사용(useState(), useReducer(), useEffect() 등)\tx\to\t브라우저 전용 API 사용\tx\to\t상태, 효과 또는 브라우저 전용 API에 종속되는 훅 사용\tx\to\tReact 클래스 컴포넌트 사용\tx\to","4-패턴#4. 패턴":"","클라이언트-컴포넌트를-상단에-배치#클라이언트 컴포넌트를 상단에 배치":"클라이언트 컴포넌트는 가능한 컴포넌트 트리의 왼쪽(앞쪽)에 위치\n\n\n// SearchBar는 클라이언트 컴포넌트\nimport SearchBar from './searchbar'\n// 로고는 서버 컴포넌트\nimport Logo from './logo'\n\n// 레이아웃은 기본적으로 서버 컴포넌트\nexport default function Layout({ children }: { children: React.ReactNode }) {\nreturn (\n<>\n<nav>\n<Logo />\n<SearchBar />\n</nav>\n<main>{children}</main>\n</>\n)\n}","컴포넌트의-랜더링#컴포넌트의 랜더링":"서버 : 모든 서버 컴포넌트 렌더링(클라이언트 컴포넌트 스킵)\n클라이언트 : 클라이언트 컴포넌트 렌더링 + 서버가 렌더링해준 서버컴포넌트 결과값을 슬롯에 삽입하여 병합\n(참고)넥스트js : 초기 페이지 진입 시 모든 컴포넌트(클라이언트 컴포넌트 포함)가 서버에서 미리 렌더링","클라이언트-컴포넌트--서버-컴포넌트-중첩#클라이언트 컴포넌트 > 서버 컴포넌트 중첩":"","잘못된-예--import-servercomponent#잘못된 예 : import {ServerComponent}":"'use client'\n\n// 서버 컴포넌트를 클라이언트 컴포넌트에 임포트하면\n// 이 컴포넌트는 클라이언트 컴포넌트 트리에 종속되어 클라이언트컴포넌트로 작동\nimport ExampleServerComponent from './example-server-component'\n\nexport default function ExampleClientComponent() {\nreturn (\n<>\n<ExampleServerComponent />\n</>\n)\n}","잘된-예-children-서버-컴포넌트-프롭-전달#잘된 예: {children} 서버 컴포넌트 프롭 전달":"// \"use client\" 디렉티브가 없는 서버컴포넌트(기본값)\nimport ExampleClientComponent from './example-client-component'\nimport ExampleServerComponent from './example-server-component'\n\nexport default function Page() {\nreturn (\n<ExampleClientComponent>\n{' '}\n{/*<- 클라이언트 컴포넌트*/}\n<ExampleServerComponent /> {/*<- 서버 컴포넌트 프롭전달*/}\n</ExampleClientComponent>\n)\n}\n\n'use client'\n\nimport { useState } from 'react'\n\nexport default function ExampleClientComponent({\nchildren, // <- 여기로 서버컴포넌트 전달\n}: {\nchildren: React.ReactNode\n}) {\nreturn (\n<>\n...\n{children} {/*<-슬롯으로 병합*/}\n</>\n)\n}\n\n참고\n컴포지션 전략 : 이 패턴은 레이아웃과 페이지에 children 프로퍼티로 이미 적용되어 사용\n컨텐츠 리프팅 전략 : 자식컴포넌트의 상태가 변경되었을때 자식컴포넌트를 리랜더링 하지 않고 부모컴포넌트에서 자식 컴포넌트 상태를 가져와서 리랜더링. 이 패턴에서도 사용됌\nchildren 프롭 외에 어떤 프롭을 사용해도 JSX를 전달할 수 있습니다","서버에서-클라이언트-컴포넌트로-프롭-전달하기직렬화#서버에서 클라이언트 컴포넌트로 프롭 전달하기(직렬화)":"서버에서 클라이언트 컴포넌트로 전달되는 프로퍼티는 직렬화 가능이어야 합니다. 즉, 함수, 날짜 등과 같은 값은 클라이언트 컴포넌트에 직접 전달할 수 없습니다.\n**네트워크 경계는 어디인가요?앱 라우터에서 네트워크 경계는 서버 컴포넌트와 클라이언트 컴포넌트 사이입니다. 이는 getStaticProps/getServerSideProps와 페이지 컴포넌트 사이에 경계가 있는 페이지와는 다릅니다. 서버 컴포넌트 내부에서 가져온 데이터는 클라이언트 컴포넌트로 전달되지 않는 한 네트워크 경계를 넘지 않으므로 직렬화할 필요가 없습니다. 서버 컴포넌트를 사용한 데이터 불러오기에 대해 자세히 알아보세요.\n\n여기 좀 자세히 설명해주실분 계실까용","서버-전용-코드를-클라이언트-컴포넌트에서-제외하기포이즌#서버 전용 코드를 클라이언트 컴포넌트에서 제외하기(포이즌)":"export async function getData() {\nconst res = await fetch('https://external-service.com/data', {\nheaders: {\nauthorization: process.env.API_KEY, // <-- 서버전용코드\n// 넥스트에서 클라이언트에서 공개 환경변수는\n// NEXT_PUBLIC 키워드를 지시해줘야함\n},\n})\n\nreturn res.json()\n}\n\nprocess.env 는 기본적으로 비공개\nNext.js는 보안 정보 유출을 방지하기 위해 클라이언트 코드에서 비공개 환경 변수를 빈 문자열로 대체\n즉 클라이언트측에서 제대로 동작하지 않음","server-only-패키지#\"server-only\" 패키지":"서버 모듈을 클라이언트 컴포넌트로 임포트하는 경우 빌드 타임 오류를 발생\n\n\nnpm install server-only\n\nimport 'server-only'\n\nexport async function getData() {\nconst res = await fetch('https://external-service.com/data', {\nheaders: {\nauthorization: process.env.API_KEY,\n},\n})\n\nreturn res.json()\n}\n\n해당 패키지 client-only를 사용하여 클라이언트 전용 코드(예: window 객체에 액세스하는 코드)가 포함된 모듈을 표시 가능","데이터-페칭#데이터 페칭":"일반적으로 서버 컴포넌트에서 데이터를 가져오는 것이 성능과 사용자 경험면에서 좋습니다.","서드파티-패키지에서의-use-client#서드파티 패키지에서의 \"use client\"":"클라이언트 단에서 사용되는 서드파티 패키지의 대부분은 \"use client\" 지시어를 사용하지 않았습니다.\n서드파티 패키지를 클라이언트 전용으로 만들어진 경우 문제가 없지만\n서버 컴포넌트에서 임포트하면 다음과 같은 문제가 발생합니다.\n\n\nimport { Carousel } from 'acme-carousel'\n\nexport default function Page() {\nreturn (\n<div>\n<p>View pictures</p>\n\n{/* Error: `useState` can not be used within Server Components */}\n<Carousel />\n</div>\n)\n}\n\n이 문제는 아래와 같이 래핑해서 해결합니다.\n\n\n'use client'\n\nimport { Carousel } from 'acme-carousel'\n\nexport default Carousel\n이제 서버 컴포넌트 내에서 바로 <Carousel />을 사용할 수 있습니다:\nimport Carousel from './carousel'\n\nexport default function Page() {\nreturn (\n<div>\n<p>View pictures</p>\n\n{/*  Works, since Carousel is a Client Component */}\n<Carousel />\n</div>\n)\n}\n\n대부분의 서드파티 패키지는 클라이언트에서 사용하지만\n공급자 컴포넌트의 경우 React 상태와 컨텍스트에 의존하고 일반적으로 애플리케이션의 루트에 필요합니다.\n서드파티 컨텍스트 프로바이더에 대해 알아보세요","라이브러리-작성자#라이브러리 작성자":"클라이언트 사이드에서 구동시킬 모듈의 경우 \"use client\" 지시어를 사용하면 사용자가 래핑 할 필요가 없습니다.\n트리에서 더 깊숙이 \"use client\"를 사용하여 가져온 모듈이 서버 컴포넌트 모듈 그래프의 일부가 되도록 함으로써 패키지를 최적화할 수 있습니다.\n일부 번들러는 번들링과 동시에 \"use client\" 지시문을 제거할 수 있다는 점에 유의할 필요가 있습니다.\n\"use client\" 지시어를 포함하도록 esbuild를 구성하는 예제는 React Wrap Balancer 및 Vercel Analytics 리포지토리에서 찾을 수 있습니다.","5-컨텍스트#5. 컨텍스트":"대부분의 React 애플리케이션은 컴포넌트 간에 데이터를 공유하기 위해 createContext를 통해 직접 또는 서드파티 라이브러리에서 가져온 공급자 컴포넌트를 통해 간접적으로 context에 의존합니다.\n컨텍스트는 클라이언트 컴포넌트에서 완벽지원\n서버컴포넌트에서 컨텍스트는 오류발생 -> 클라이언트 컴포넌트로 래핑해서 사용","클라이언트-컴포넌트에서-컨텍스트-사용하기#클라이언트 컴포넌트에서 컨텍스트 사용하기":"'use client'\n\nimport { createContext, useContext, useState } from 'react'\n\nconst SidebarContext = createContext()\n\nexport function Sidebar() {\nconst [isOpen, setIsOpen] = useState()\n\nreturn (\n<SidebarContext.Provider value={{ isOpen }}>\n<SidebarNav />\n</SidebarContext.Provider>\n)\n}\n\nfunction SidebarNav() {\nlet { isOpen } = useContext(SidebarContext)\n\nreturn (\n<div>\n<p>Home</p>\n\n{isOpen && <Subnav />}\n</div>\n)\n}\n\n그러나 컨텍스트 공급자는 일반적으로 현재 테마와 같은 글로벌 관심사를 공유하기 위해 애플리케이션의 루트 근처에 렌더링됩니다.\n컨텍스트는 서버 컴포넌트에서 지원되지 않으므로 애플리케이션의 루트에서 컨텍스트를 만들려고 하면 오류가 발생합니다:\n\n\nimport { createContext } from 'react'\n\n//  createContext is not supported in Server Components\nexport const ThemeContext = createContext({})\n\nexport default function RootLayout({ children }) {\nreturn (\n<html>\n<body>\n<ThemeContext.Provider value=\"dark\">{children}</ThemeContext.Provider>\n</body>\n</html>\n)\n}\n\n이 문제를 해결하려면 컨텍스트를 생성하고 클라이언트 컴포넌트 내에서 해당 프로바이더를 렌더링하세요:\n\n\n'use client'\n\nimport { createContext } from 'react'\n\nexport const ThemeContext = createContext({})\n\nexport default function ThemeProvider({ children }) {\nreturn <ThemeContext.Provider value=\"dark\">{children}</ThemeContext.Provider>\n}\n\n이제 서버 컴포넌트가 클라이언트 컴포넌트로 표시되었으므로 공급자를 직접 렌더링할 수 있습니다:\n\n\nimport ThemeProvider from './theme-provider'\n\nexport default function RootLayout({ children }) {\nreturn (\n<html>\n<body>\n<ThemeProvider>{children}</ThemeProvider>\n</body>\n</html>\n)\n}","서버-컴포넌트에서-서드파티-컨텍스트-제공자-렌더링하기#서버 컴포넌트에서 서드파티 컨텍스트 제공자 렌더링하기":"서드파티 패키지는 \"use client\" 디렉티브가 없을 경우가 많고\n서버컴포넌트에서 이런 패키지를 사용하려면 다음과 같은 오류가 발생할 수 있습니다\n\n\nimport { ThemeProvider } from 'acme-theme'\n\nexport default function RootLayout({ children }) {\nreturn (\n<html>\n<body>\n{/*  Error: `createContext` can't be used in Server Components */}\n<ThemeProvider>{children}</ThemeProvider>\n</body>\n</html>\n)\n}\n\n클라이언트 컴포넌트로 래핑하면 해결됩니다\n\n\n'use client'\n\nimport { ThemeProvider } from 'acme-theme'\nimport { AuthProvider } from 'acme-auth'\n\nexport function Providers({ children }) {\nreturn (\n<ThemeProvider>\n<AuthProvider>{children}</AuthProvider>\n</ThemeProvider>\n)\n}\n\nimport { Providers } from './providers'\n\nexport default function RootLayout({ children }) {\nreturn (\n<html>\n<body>\n<Providers>{children}</Providers>\n</body>\n</html>\n)\n}","서버-컴포넌트-간-데이터-공유#서버 컴포넌트 간 데이터 공유":"서버 컴포넌트는 인터랙티브하지 않고 React 상태값이나 컨텍스트를 사용하지 않습니다.\n대신 여러 서버 컴포넌트가 액세스해야 하는 공통 데이터에 네이티브 자바스크립트 패턴을 사용할 수 있습니다.\n예를 들어 모듈을 사용해 여러 컴포넌트에서 데이터베이스 연결을 공유할 수 있습니다:\n\n\n// 글로벌 싱글톤 공유\nexport const db = new DatabaseConnection()\n\nimport { db } from '@utils/database'\n\nexport async function UsersLayout() {\nlet users = await db.query()\n// ...\n}\n\nimport { db } from '@utils/database'\n\nexport async function DashboardPage() {\nlet user = await db.query()\n// ...\n}","서버-컴포넌트-간-fetch-요청-값-공유#서버 컴포넌트 간 fetch 요청 값 공유":"여러 컴포넌트에서 하나의 페치데이터 결과를 공유하고 싶을 때, 프롭스로 전달 가능하지만\n넥스트에서는 데이터 fetch의 중복요청이 있을 때, 에서 자동적으로 캐싱이 이루어지며, 같은 fetch 의 결과물을 공유 받을 수 있습니다."}}}