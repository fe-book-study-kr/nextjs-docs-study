{"/":{"title":"Nextjs Study!","data":{"":"넥스트js 스터디 with Nextra","_metajson에-대해#_meta.json에 대해":"폴더로 문서의 계층을 구성할 수 있습니다\n해당 파일로 라우터의 순서와 보여지는 이름을 분리시킬 수 있습니다\n_meta.json 파일이 작성되어있지 않아도 작동은하지만\n_meta.json 파일로 문서구조의 순서를 바로잡을 수 있습니다\n_meta.json 파일은 \"실제 폴더-파일명\" : \"문서계층의 폴더-파일명\" 으로 구성됩니다\n파일과 폴더명은 넥스트라처럼 사용하였습니다 (띄어쓰기:-)","이미지첨부에-대해#이미지첨부에 대해":"이미지 이름은 '페이지이름-이미지이름'으로 했습니다.\n마크다운에 이미지 첨부하는 형식은 ![이미지 설명](./이미지 경로)\n에셋폴더에 보관하는것보다 문서랑 가까이두면 좋을것같아서요. 다른 의견있으시면 알려주세용"}},"/page-router/routing/defining-routes":{"title":"Defining Routes","data":{"":""}},"/getting-started/react-essentials":{"title":"React Essentials","data":{"":"","1-서버-컴포넌트#1. 서버 컴포넌트":"클라이언트 컴포넌트(csr) + 서버 컴포넌트(ssr) => 하이브리드","서버-컴포넌트-생각해보기#서버 컴포넌트 생각해보기":"페이지를 컴포넌트 단위로 쪼개다보면 대부분의 컴포넌트는 인터렉션이 없어 서버에서 렌더링이 가능\n인터렉티브 UI의 경우를 제한적으로 클라이언트 컴포넌트로 사용","왜-서버-컴포넌트인가#왜 서버 컴포넌트인가?":"","csr의-경우#CSR의 경우":"느린 초기로딩\n이후 빠른 반응성\n인터렉션 연산을 클라이언트측에 위임","ssr의-경우#SSR의 경우":"빠른 초기 로딩\n라우터 전환시마다 페이지 로딩이 필요","서버-컴포넌트를-사용하면#서버 컴포넌트를 사용하면":"데이터베이스에 더 가까운 서버로 데이터 로드,\n큰 자바스크립트 번들구성을 서버에 유지하여 성능 향상\n서버 컴포넌트를 사용하면 React의 성능과 유연성, UI 템플릿을 위한 컴포넌트 모델을 사용 가능\n클라이언트 컴포넌트와 서버컴포넌트는 점진적으로 클라이언트에게 인계되며\n상호작용을 추가할 수 있도록 서버와 클라이언트 측 런타임을 비동기적으로 로드\n서버컴포넌트는 앱라우터를 포함하여, 스페셜 파일, 코로케이션 컴포넌트를 지칭","2-클라이언트-컴포넌트#2. 클라이언트 컴포넌트":"주로 애플리케이션에 클라이언트 측 인터랙션을 담당\n클라이언트 컴포넌트는 넥스트에서 미리 랜더링되어짐.\nHTML뼈대 생성\n리액트 자바스크립트 채워주기(하이드레이트)\n\n\n페이지 라우터가 항상 작동하는 방식","use-client-디렉티브#\"use client\" 디렉티브":"\"use client\" 디렉티브를 통해 클라이언트 컴포넌트로 동작\n'use client'\n\nimport { useState } from 'react'\n\nexport default function Counter() {\nconst [count, setCount] = useState(0)\n\nreturn (\n<div>\n<p>You clicked {count} times</p>\n<button onClick={() => setCount(count + 1)}>Click me</button>\n</div>\n)\n}\n\n'use client'\n\nimport { useState } from 'react'\n\nexport default function Counter() {\nconst [count, setCount] = useState(0)\n\nreturn (\n<div>\n<p>You clicked {count} times</p>\n<button onClick={() => setCount(count + 1)}>Click me</button>\n</div>\n)\n}\n\n알아두면 좋은 정보:\n\"use client\"\n임포트 문 위에 위치\n!! 해당 파일에서 임포트한 하위 모듈은 클라이언트 번들로 간주\n이 규칙 때문에 본문에서는 경계라고 표현\n클라이언트 컴포넌트의 최상위 컴포넌트만 디렉티브를 사용하면 됌\n\n\n해당 디렉티브가 없는 모든 컴포넌트는 서버 컴포넌트 -> 서버에서만 렌더링\n(next의 경우) 클라이언트 컴포넌트는 서버에서 미리 렌더링한 후 클라이언트에 하이드레이션\n\n참고\n모듈그래프라는 포현은 넥스트js의 모듈 표현법으로 의존관계에 있는 모듈들이 그래프구조로 연결되기 때문에 모듈그래프라 지칭\n해당 본문에는 모듈그래프라는 표현을 제거해도 이해에 문제가 없을것으로 판단하여 해당표현을 삭제함","3-서버-컴포넌트와-클라이언트-컴포넌트는-언제-사용해야-하나요#3. 서버 컴포넌트와 클라이언트 컴포넌트는 언제 사용해야 하나요?":"기본 : 서버컴포넌트\n\n\n서버 컴포넌트\t클라이언트 컴포넌트\t서버에 민감한 정보(액세스 토큰, API 키 등) 보관\tx\tx\t데이터를 가져옵니다.\to\tx\t백엔드 리소스에 직접 액세스 (직접)\to\tx\t서버에 대한 대규모 종속성 유지/클라이언트 측 자바스크립트 감소\to\tx\t상호작용 및 이벤트 리스너 추가(onClick(), onChange() 등)\tx\to\t상태 및 수명 주기 효과 사용(useState(), useReducer(), useEffect() 등)\tx\to\t브라우저 전용 API 사용\tx\to\t상태, 효과 또는 브라우저 전용 API에 종속되는 훅 사용\tx\to\tReact 클래스 컴포넌트 사용\tx\to","4-패턴#4. 패턴":"","클라이언트-컴포넌트를-상단에-배치#클라이언트 컴포넌트를 상단에 배치":"클라이언트 컴포넌트는 가능한 컴포넌트 트리의 왼쪽(앞쪽)에 위치\n\n\n// SearchBar는 클라이언트 컴포넌트\nimport SearchBar from './searchbar'\n// 로고는 서버 컴포넌트\nimport Logo from './logo'\n\n// 레이아웃은 기본적으로 서버 컴포넌트\nexport default function Layout({ children }: { children: React.ReactNode }) {\nreturn (\n<>\n<nav>\n<Logo />\n<SearchBar />\n</nav>\n<main>{children}</main>\n</>\n)\n}","클라이언트-및-서버-컴포넌트-구성하기#클라이언트 및 서버 컴포넌트 구성하기":"서버 컴포넌트와 클라이언트 컴포넌트는 같은 컴포넌트 트리에서 결합할 수 있습니다.백그라운드에서 React는 다음과 같이 렌더링을 처리합니다:\n서버에서 React는 결과를 클라이언트로 보내기 전에 모든 서버 컴포넌트를 렌더링합니다.\n여기에는 클라이언트 컴포넌트 안에 중첩된 서버 컴포넌트가 포함됩니다.\n이 단계에서 발생하는 클라이언트 컴포넌트는 건너뜁니다.\n\n\n클라이언트에서 React는 클라이언트 컴포넌트를 렌더링하고 서버 컴포넌트의 렌더링 결과를 슬롯에 삽입하여 서버와 클라이언트에서 수행한 작업을 병합합니다.\n서버 컴포넌트가 클라이언트 컴포넌트 안에 중첩된 경우, 렌더링된 콘텐츠는 클라이언트 컴포넌트 안에 올바르게 배치됩니다.\n\n\n\n\n알아두면 좋은 정보: Next.js에서는 초기 페이지 로딩 시 위 단계의 서버 컴포넌트와 클라이언트 컴포넌트의 렌더링 결과가 모두 서버에서 HTML로 미리 렌더링되어 초기 페이지 로딩이 빨라집니다.","클라이언트-컴포넌트-안에-서버-컴포넌트-중첩하기#클라이언트 컴포넌트 안에 서버 컴포넌트 중첩하기":"위에서 설명한 렌더링 흐름을 고려할 때 서버 컴포넌트를 클라이언트 컴포넌트로 가져오는 데는 제한이 있는데, 이 접근 방식은 추가 서버 왕복이 필요하기 때문입니다.","지원되지-않는-패턴입니다-서버-컴포넌트를-클라이언트-컴포넌트로-임포트하기#지원되지 않는 패턴입니다: 서버 컴포넌트를 클라이언트 컴포넌트로 임포트하기":"다음 패턴은 지원되지 않습니다. 서버 컴포넌트를 클라이언트 컴포넌트로 임포트할 수 없습니다:\n'use client'\n\n// 이 패턴은 **작동하지** 않습니다!\n// 서버 컴포넌트를 클라이언트 컴포넌트로 임포트할 수 없습니다.\nimport ExampleServerComponent from './example-server-component'\n\nexport default function ExampleClientComponent({\nchildren,\n}: {\nchildren: React.ReactNode\n}) {\nconst [count, setCount] = useState(0)\n\nreturn (\n<>\n<button onClick={() => setCount(count + 1)}>{count}</button>\n\n<ExampleServerComponent />\n</>\n)\n}","권장-패턴-서버-컴포넌트를-클라이언트-컴포넌트에-프롭으로-전달하기#권장 패턴: 서버 컴포넌트를 클라이언트 컴포넌트에 프롭으로 전달하기":"대신, 클라이언트 컴포넌트를 디자인할 때 React 프로퍼티를 사용하여 서버 컴포넌트에 \"슬롯\"을 표시할 수 있습니다.서버 컴포넌트는 서버에서 렌더링되고 클라이언트 컴포넌트가 클라이언트에서 렌더링될 때 \"슬롯\"은 서버 컴포넌트의 렌더링된 결과로 채워집니다.일반적인 패턴은 React children 프로퍼티를 사용해 \"슬롯\"을 생성하는 것입니다. 일반적인 children 프로퍼티를 허용하도록 <ExampleClientComponent>를 리팩터링하고 <ExampleClientComponent>의 임포트와 명시적 중첩을 부모 컴포넌트로 옮길 수 있습니다.\n'use client'\n\nimport { useState } from 'react'\n\nexport default function ExampleClientComponent({\nchildren,\n}: {\nchildren: React.ReactNode\n}) {\nconst [count, setCount] = useState(0)\n\nreturn (\n<>\n<button onClick={() => setCount(count + 1)}>{count}</button>\n\n{children}\n</>\n)\n}\n이제 <ExampleClientComponent>는 children이 무엇인지 전혀 알지 못합니다. 사실, 자식이 결국 서버 컴포넌트의 결과에 의해 채워질 것이라는 사실조차 알지 못합니다.예제 클라이언트 컴포넌트가 할 수 있는 유일한 책임은 결국 자식이 어디에 위치할지 결정하는 것뿐입니다.부모 서버 컴포넌트에서 <ExampleClientComponent>와 <ExampleServerComponent>를 모두 임포트하고 <ExampleServerComponent>를 <ExampleClientComponent>의 자식으로 전달할 수 있습니다:\n// 이 패턴이 작동합니다:\n// 서버 컴포넌트를 클라이언트 컴포넌트의 자식이나 프로퍼티로 전달할 수 있습니다.\n// 클라이언트 컴포넌트의 자식 또는 프로퍼티로 전달할 수 있습니다.\nimport ExampleClientComponent from './example-client-component'\nimport ExampleServerComponent from './example-server-component'\n\n// Next.js의 페이지는 기본적으로 서버 컴포넌트입니다.\nexport default function Page() {\nreturn (\n<ExampleClientComponent>\n<ExampleServerComponent />\n</ExampleClientComponent>\n)\n}\n이 접근 방식을 사용하면 <예제 클라이언트 컴포넌트>와 <예제 서버 컴포넌트>의 렌더링이 분리되어 독립적으로 렌더링될 수 있으며, 클라이언트 컴포넌트보다 먼저 서버에서 렌더링되는 서버 컴포넌트에 맞춰 조정됩니다.\n알아두면 좋은 정보\n이 패턴은 레이아웃과 페이지에 children 프로퍼티로 이미 적용되어 있으므로 추가 래퍼 컴포넌트를 만들 필요가 없습니다.\nReact 컴포넌트(JSX)를 다른 컴포넌트에 전달하는 것은 새로운 개념이 아니며 항상 React 컴포지션 모델의 일부였습니다.\n이 컴포지션 전략은 서버와 클라이언트 컴포넌트 모두에서 작동하는데, 소품을 받는 컴포넌트는 소품이 무엇인지 전혀 모르기 때문입니다. 단지 전달받은 소품이 어디에 배치되어야 하는지에 대해서만 책임이 있습니다. - 전달된 소품이 클라이언트 컴포넌트가 클라이언트에서 렌더링되기 훨씬 전에 서버에서 독립적으로 렌더링될 수 있습니다. - 가져온 중첩된 자식 컴포넌트를 다시 렌더링하는 부모 컴포넌트의 상태 변화를 피하기 위해 \"콘텐츠 리프팅\"이라는 동일한 전략이 사용되었습니다.\nchildren 프로퍼티에만 국한되지 않습니다. 어떤 프롭을 사용해도 JSX를 전달할 수 있습니다.","서버에서-클라이언트-컴포넌트로-프롭-전달하기직렬화#서버에서 클라이언트 컴포넌트로 프롭 전달하기(직렬화)":"서버에서 클라이언트 컴포넌트로 전달되는 프로퍼티는 직렬화 가능이어야 합니다. 즉, 함수, 날짜 등과 같은 값은 클라이언트 컴포넌트에 직접 전달할 수 없습니다.\n**네트워크 경계는 어디인가요?앱 라우터에서 네트워크 경계는 서버 컴포넌트와 클라이언트 컴포넌트 사이입니다. 이는 getStaticProps/getServerSideProps와 페이지 컴포넌트 사이에 경계가 있는 페이지와는 다릅니다. 서버 컴포넌트 내부에서 가져온 데이터는 클라이언트 컴포넌트로 전달되지 않는 한 네트워크 경계를 넘지 않으므로 직렬화할 필요가 없습니다. 서버 컴포넌트를 사용한 데이터 불러오기에 대해 자세히 알아보세요.","서버-전용-코드를-클라이언트-컴포넌트에서-제외하기포이즌#서버 전용 코드를 클라이언트 컴포넌트에서 제외하기(포이즌)":"자바스크립트 모듈은 서버와 클라이언트 컴포넌트 모두에서 공유할 수 있기 때문에 서버에서만 실행되어야 하는 코드가 클라이언트로 몰래 들어갈 수 있습니다.예를 들어 다음 데이터 불러오기 함수를 살펴봅시다:\nexport async function getData() {\nconst res = await fetch('https://external-service.com/data', {\nheaders: {\nauthorization: process.env.API_KEY,\n},\n})\n\nreturn res.json()\n}\n\nexport async function getData() {\nconst res = await fetch('https://external-service.com/data', {\nheaders: {\nauthorization: process.env.API_KEY,\n},\n})\n\nreturn res.json()\n}\n언뜻 보기에는 getData가 서버와 클라이언트 모두에서 작동하는 것처럼 보입니다. 하지만 환경 변수 API_KEY 앞에 NEXT_PUBLIC이 붙지 않았기 때문에 서버에서만 액세스할 수 있는 비공개 변수입니다. Next.js는 보안 정보 유출을 방지하기 위해 클라이언트 코드에서 비공개 환경 변수를 빈 문자열로 대체합니다.따라서 클라이언트에서 getData()를 가져와서 실행할 수 있지만 예상대로 작동하지 않습니다. 또한 변수를 공개하면 클라이언트에서 함수가 작동하지만 민감한 정보가 유출될 수 있습니다.따라서 이 함수는 서버에서만 실행되도록 의도하여 작성되었습니다.","서버-전용-패키지#\"서버 전용\" 패키지":"클라이언트가 서버 코드를 의도치 않게 사용하는 것을 방지하기 위해, 다른 개발자가 실수로 이러한 모듈 중 하나를 클라이언트 컴포넌트로 임포트하는 경우 빌드 타임 오류를 발생시키는 server-only 패키지를 사용할 수 있습니다.server-only을 사용하려면 먼저 패키지를 설치합니다:\nnpm install server-only\n그런 다음 패키지를 서버 전용 코드가 포함된 모듈로 가져옵니다:\nimport 'server-only'\n\nexport async function getData() {\nconst res = await fetch('https://external-service.com/data', {\nheaders: {\nauthorization: process.env.API_KEY,\n},\n})\n\nreturn res.json()\n}\n이제 getData()를 임포트하는 모든 클라이언트 컴포넌트는 이 모듈이 서버에서만 사용할 수 있음을 설명하는 빌드 타임 오류를 받게 됩니다.해당 패키지 client-only를 사용하여 클라이언트 전용 코드(예: window 객체에 액세스하는 코드)가 포함된 모듈을 표시할 수 있습니다.","데이터-가져오기#데이터 가져오기":"클라이언트 컴포넌트에서 데이터를 가져올 수 있지만 클라이언트에서 데이터를 가져와야 하는 특별한 이유가 없다면 서버 컴포넌트에서 데이터를 가져오는 것이 좋습니다. 데이터 불러오기를 서버로 옮기면 성능과 사용자 경험이 향상됩니다.데이터 불러오기에 대해 자세히 알아보기를 참조하세요.","서드파티-패키지#서드파티 패키지":"서버 컴포넌트는 새로운 것이기 때문에 에코시스템의 서드파티 패키지는 이제 막 useState, useEffect, createContext와 같은 클라이언트 전용 기능을 사용하는 컴포넌트에 \"use client\" 지시어를 추가하기 시작했습니다.오늘날, 클라이언트 전용 기능을 사용하는 npm 패키지의 많은 컴포넌트에는 아직 이 지시어가 없습니다. 이러한 서드파티 컴포넌트는 사용 클라이언트 지시어를 가지고 있기 때문에 자체 클라이언트 컴포넌트 내에서 예상대로 작동하지만, 서버 컴포넌트 내에서는 작동하지 않습니다.예를 들어 <캐러셀 /> 컴포넌트가 있는 가상의 acme-carousel 패키지를 설치했다고 가정해 보겠습니다. 이 컴포넌트는 useState를 사용하지만 아직 \"use client\" 지시어가 없습니다.클라이언트 컴포넌트 내에서 <Carousel />을 사용하면 예상대로 작동합니다:\n'use client'\n\nimport { useState } from 'react'\nimport { Carousel } from 'acme-carousel'\n\nexport default function Gallery() {\nlet [isOpen, setIsOpen] = useState(false)\n\nreturn (\n<div>\n<button onClick={() => setIsOpen(true)}>View pictures</button>\n\n{/* Works, since Carousel is used within a Client Component */}\n{isOpen && <Carousel />}\n</div>\n)\n}\n그러나 서버 컴포넌트 내에서 직접 사용하려고 하면 오류가 표시됩니다:\nimport { Carousel } from 'acme-carousel'\n\nexport default function Page() {\nreturn (\n<div>\n<p>View pictures</p>\n\n{/* Error: `useState` can not be used within Server Components */}\n<Carousel />\n</div>\n)\n}\n이는 <Carousel />이 클라이언트 전용 기능을 사용하고 있다는 것을 Next.js가 알지 못하기 때문입니다.이 문제를 해결하려면 클라이언트 전용 기능에 의존하는 타사 컴포넌트를 자체 클라이언트 컴포넌트로 래핑하면 됩니다:\n'use client'\n\nimport { Carousel } from 'acme-carousel'\n\nexport default Carousel\n이제 서버 컴포넌트 내에서 바로 <Carousel />을 사용할 수 있습니다:\nimport Carousel from './carousel'\n\nexport default function Page() {\nreturn (\n<div>\n<p>View pictures</p>\n\n{/*  Works, since Carousel is a Client Component */}\n<Carousel />\n</div>\n)\n}\n대부분의 서드파티 컴포넌트는 클라이언트 컴포넌트 내에서 사용할 가능성이 높기 때문에 래핑할 필요가 없을 것으로 예상합니다. 그러나 한 가지 예외는 공급자 컴포넌트인데, 이는 React 상태와 컨텍스트에 의존하고 일반적으로 애플리케이션의 루트에 필요하기 때문입니다. 아래에서 서드파티 컨텍스트 프로바이더에 대해 자세히 알아보세요.","라이브러리-작성자#라이브러리 작성자":"비슷한 방식으로 다른 개발자가 사용할 패키지를 만드는 라이브러리 작성자는 \"use client\" 지시어를 사용하여 패키지의 클라이언트 진입점을 표시할 수 있습니다. 이렇게 하면 패키지 사용자가 래핑 경계를 만들지 않고도 패키지 컴포넌트를 자신의 서버 컴포넌트로 직접 가져올 수 있습니다.\n트리에서 더 깊숙이 'use client'를 사용하여 가져온 모듈이 서버 컴포넌트 모듈 그래프의 일부가 되도록 함으로써 패키지를 최적화할 수 있습니다.\n일부 번들러는 \"use client\" 지시문을 제거할 수 있다는 점에 유의할 필요가 있습니다. \"use client\" 지시어를 포함하도록 esbuild를 구성하는 예제는 React Wrap Balancer 및 Vercel Analytics 리포지토리에서 찾을 수 있습니다.","5-컨텍스트#5. 컨텍스트":"대부분의 React 애플리케이션은 컴포넌트 간에 데이터를 공유하기 위해 createContext를 통해 직접 또는 서드파티 라이브러리에서 가져온 공급자 컴포넌트를 통해 간접적으로 context에 의존합니다.Next.js 13에서 컨텍스트는 클라이언트 컴포넌트 내에서 완벽하게 지원되지만, 서버 컴포넌트 내에서 직접 생성하거나 사용할 수는 없습니다. 서버 컴포넌트에는 (상호작용이 아니기 때문에) React state가 없고, 컨텍스트는 주로 일부 React state가 업데이트된 후 트리 깊숙한 곳에 있는 인터랙티브 컴포넌트를 다시 렌더링하는 데 사용되기 때문입니다.서버 컴포넌트 간에 데이터를 공유하기 위한 대안은 나중에 논의하겠지만, 먼저 클라이언트 컴포넌트 내에서 컨텍스트를 사용하는 방법을 살펴봅시다.","클라이언트-컴포넌트에서-컨텍스트-사용하기#클라이언트 컴포넌트에서 컨텍스트 사용하기":"모든 컨텍스트 API는 클라이언트 컴포넌트 내에서 완벽하게 지원됩니다:\n'use client'\n\nimport { createContext, useContext, useState } from 'react'\n\nconst SidebarContext = createContext()\n\nexport function Sidebar() {\nconst [isOpen, setIsOpen] = useState()\n\nreturn (\n<SidebarContext.Provider value={{ isOpen }}>\n<SidebarNav />\n</SidebarContext.Provider>\n)\n}\n\nfunction SidebarNav() {\nlet { isOpen } = useContext(SidebarContext)\n\nreturn (\n<div>\n<p>Home</p>\n\n{isOpen && <Subnav />}\n</div>\n)\n}\n그러나 컨텍스트 공급자는 일반적으로 현재 테마와 같은 글로벌 관심사를 공유하기 위해 애플리케이션의 루트 근처에 렌더링됩니다. 컨텍스트는 서버 컴포넌트에서 지원되지 않으므로 애플리케이션의 루트에서 컨텍스트를 만들려고 하면 오류가 발생합니다:\nimport { createContext } from 'react'\n\n//  createContext is not supported in Server Components\nexport const ThemeContext = createContext({})\n\nexport default function RootLayout({ children }) {\nreturn (\n<html>\n<body>\n<ThemeContext.Provider value=\"dark\">{children}</ThemeContext.Provider>\n</body>\n</html>\n)\n}\n이 문제를 해결하려면 컨텍스트를 생성하고 클라이언트 컴포넌트 내에서 해당 프로바이더를 렌더링하세요:\n'use client'\n\nimport { createContext } from 'react'\n\nexport const ThemeContext = createContext({})\n\nexport default function ThemeProvider({ children }) {\nreturn <ThemeContext.Provider value=\"dark\">{children}</ThemeContext.Provider>\n}\n이제 서버 컴포넌트가 클라이언트 컴포넌트로 표시되었으므로 공급자를 직접 렌더링할 수 있습니다:\nimport ThemeProvider from './theme-provider'\n\nexport default function RootLayout({ children }) {\nreturn (\n<html>\n<body>\n<ThemeProvider>{children}</ThemeProvider>\n</body>\n</html>\n)\n}\n프로바이더가 루트에서 렌더링되면 앱의 다른 모든 클라이언트 컴포넌트가 이 컨텍스트를 사용할 수 있습니다.\n알아두면 좋은 정보: 제공자는 트리에서 가능한 한 깊숙이 렌더링해야 합니다. ThemeProvider가 전체 <html> 문서 대신 {children}만 래핑하는 것을 주목하세요. 이렇게 하면 Next.js가 서버 컴포넌트의 정적 부분을 더 쉽게 최적화할 수 있습니다.","서버-컴포넌트에서-서드파티-컨텍스트-제공자-렌더링하기#서버 컴포넌트에서 서드파티 컨텍스트 제공자 렌더링하기":"서드파티 npm 패키지에는 애플리케이션의 루트 근처에서 렌더링해야 하는 프로바이더가 포함되어 있는 경우가 많습니다. 이러한 프로바이더에 \"use client\" 지시어가 포함된 경우, 서버 컴포넌트 내부에서 직접 렌더링할 수 있습니다. 그러나 서버 컴포넌트는 매우 새롭기 때문에 많은 서드파티 공급자가 아직 이 지시문을 추가하지 않았을 것입니다.\"use client\"가 없는 서드파티 공급자를 렌더링하려고 하면 오류가 발생합니다:\nimport { ThemeProvider } from 'acme-theme'\n\nexport default function RootLayout({ children }) {\nreturn (\n<html>\n<body>\n{/*  Error: `createContext` can't be used in Server Components */}\n<ThemeProvider>{children}</ThemeProvider>\n</body>\n</html>\n)\n}\n이 문제를 해결하려면 타사 제공업체를 자체 클라이언트 컴포넌트로 래핑하세요:\n'use client'\n\nimport { ThemeProvider } from 'acme-theme'\nimport { AuthProvider } from 'acme-auth'\n\nexport function Providers({ children }) {\nreturn (\n<ThemeProvider>\n<AuthProvider>{children}</AuthProvider>\n</ThemeProvider>\n)\n}\n이제 루트 레이아웃 내에서 바로 <Providers />를 가져와 렌더링할 수 있습니다.\nimport { Providers } from './providers'\n\nexport default function RootLayout({ children }) {\nreturn (\n<html>\n<body>\n<Providers>{children}</Providers>\n</body>\n</html>\n)\n}\n루트에서 렌더링된 프로바이더를 사용하면 이러한 라이브러리의 모든 컴포넌트와 후크가 자체 클라이언트 컴포넌트 내에서 예상대로 작동합니다.타사 라이브러리가 클라이언트 코드에 \"use client\"를 추가하면 래퍼 클라이언트 컴포넌트를 제거할 수 있습니다.","서버-컴포넌트-간-데이터-공유#서버 컴포넌트 간 데이터 공유":"서버 컴포넌트는 인터랙티브하지 않으므로 React 상태에서 읽지 않으므로 데이터를 공유하기 위해 React 컨텍스트가 필요하지 않습니다. 대신 여러 서버 컴포넌트가 액세스해야 하는 공통 데이터에 네이티브 자바스크립트 패턴을 사용할 수 있습니다. 예를 들어 모듈을 사용해 여러 컴포넌트에서 데이터베이스 연결을 공유할 수 있습니다:\nexport const db = new DatabaseConnection()\n\nimport { db } from '@utils/database'\n\nexport async function UsersLayout() {\nlet users = await db.query()\n// ...\n}\n\nimport { db } from '@utils/database'\n\nexport async function DashboardPage() {\nlet user = await db.query()\n// ...\n}\n위의 예시에서는 레이아웃과 페이지 모두 데이터베이스 쿼리를 수행해야 합니다. 이러한 각 컴포넌트는 @utils/database 모듈을 가져와서 데이터베이스에 대한 액세스를 공유합니다. 이 자바스크립트 패턴을 글로벌 싱글톤이라고 합니다.","서버-컴포넌트-간-가져오기-요청-공유하기#서버 컴포넌트 간 가져오기 요청 공유하기":"데이터를 불러올 때 페이지 또는 레이아웃과 일부 하위 컴포넌트 간에 fetch 결과를 공유하고 싶을 수 있습니다. 이는 컴포넌트 간에 불필요한 결합이며 컴포넌트 간에 프로퍼티를 앞뒤로 전달할 수 있습니다.대신 데이터를 소비하는 컴포넌트와 함께 데이터 가져오기를 배치하는 것이 좋습니다. 서버 컴포넌트에서 fetch 요청은 자동으로 중복 제거됨을 사용하면 각 경로 세그먼트가 중복 요청 걱정 없이 필요한 데이터를 정확하게 요청할 수 있습니다. Next.js는 fetch 캐시에서 동일한 값을 읽습니다."}}}